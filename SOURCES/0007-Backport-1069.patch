From b29830fd3da4dbb98e3d6f3fb06f8ff698fff377 Mon Sep 17 00:00:00 2001
From: Stephen Dolan <mu@netsoc.tcd.ie>
Date: Tue, 7 Mar 2017 10:24:46 +0000
Subject: [PATCH 2/2] Backport optimisation of switches to lookup tables (ocaml
 #1069)

Signed-off-by: Marcello Seri <marcello.seri@citrix.com>
---
 asmcomp/cmmgen.ml                           | 74 ++++++++++++++++++-----------
 testsuite/tests/basic/switch_opts.ml        | 63 ++++++++++++++++++++++++
 testsuite/tests/basic/switch_opts.reference |  1 +
 3 files changed, 109 insertions(+), 29 deletions(-)
 create mode 100644 testsuite/tests/basic/switch_opts.ml
 create mode 100644 testsuite/tests/basic/switch_opts.reference

diff --git a/asmcomp/cmmgen.ml b/asmcomp/cmmgen.ml
index 4db151e7b..431964974 100644
--- a/asmcomp/cmmgen.ml
+++ b/asmcomp/cmmgen.ml
@@ -776,8 +776,17 @@ let transl_structured_constant cst =
 
 type is_global = Global | Not_global
 
-let constant_closures =
-  ref ([] : ((string * is_global) * ufunction list * uconstant list) list)
+type symbol_defn = string * is_global
+
+type cmm_constant =
+  | Const_closure of symbol_defn * ufunction list * uconstant list
+  | Const_table of symbol_defn * data_item list
+
+let cmm_constants =
+  ref ([] : cmm_constant list)
+
+let add_cmm_constant c =
+  cmm_constants := c :: !cmm_constants
 
 (* Boxed integers *)
 
@@ -1238,33 +1247,32 @@ let transl_isout h arg = tag_int (Cop(Ccmpa Clt, [h ; arg]))
 
 (* Build an actual switch (ie jump table) *)
 
-let make_switch arg cases actions dbg =
+let make_switch arg cases actions =
   let is_const = function
+    (* Constant integers loaded from a table should end in 1,
+       so that Cload never produces untagged integers *)
     | Cconst_int n
     | Cconst_pointer n -> (n land 1) = 1
-    | Cconst_natint _
-    | Cconst_float _
+    | Cconst_natint n
+    | Cconst_natpointer n -> (Nativeint.(to_int (logand n one) = 1))
     | Cconst_symbol _ -> true
     | _ -> false in
   if Array.for_all is_const actions then
-    let const c =
-      let sym = Compilenv.new_structured_constant ~shared:true c in
-      Uconst_ref(sym, Some c) in
-    let to_uconst = function
-      | Cconst_int n -> Uconst_int (n lsr 1)
-      | Cconst_pointer n -> Uconst_ptr (n lsr 1)
-      | Cconst_symbol s -> Uconst_ref (s, None)
-      | Cconst_natint n -> const (Uconst_nativeint n)
-      | Cconst_float f -> const (Uconst_float f)
+    let to_data_item = function
+      | Cconst_int n
+      | Cconst_pointer n -> Cint (Nativeint.of_int n)
+      | Cconst_natint n
+      | Cconst_natpointer n -> Cint n
+      | Cconst_symbol s -> Csymbol_address s
       | _ -> assert false in
-    let const_actions = Array.map to_uconst actions in
-    let table = Compilenv.new_structured_constant ~shared:true
-      (Uconst_block (0,
+    let const_actions = Array.map to_data_item actions in
+    let table = Compilenv.new_const_symbol () in
+    add_cmm_constant (Const_table ((table, Not_global),
         Array.to_list (Array.map (fun act ->
-          const_actions.(act)) cases))) in
-    addr_array_ref (Cconst_symbol table) (tag_int arg dbg) dbg
+          const_actions.(act)) cases)));
+    addr_array_ref (Cconst_symbol table) (tag_int arg)
   else
-    Cswitch (arg,cases,actions,dbg)
+    Cswitch (arg,cases,actions)
 
 module SArgBlocks =
 struct
@@ -1286,7 +1294,7 @@ struct
   let make_isin h arg =  Cop (Ccmpa Cge, [h ; arg])
   let make_if cond ifso ifnot = Cifthenelse (cond, ifso, ifnot)
   let make_switch arg cases actions =
-    make_switch arg cases actions Debuginfo.none
+    make_switch arg cases actions
   let bind arg body = bind "switcher" arg body
 
   let make_catch handler = match handler with
@@ -1505,8 +1513,8 @@ let rec transl env e =
       transl_constant sc
   | Uclosure(fundecls, []) ->
       let lbl = Compilenv.new_const_symbol() in
-      constant_closures :=
-        ((lbl, Not_global), fundecls, []) :: !constant_closures;
+      add_cmm_constant (
+        Const_closure ((lbl, Not_global), fundecls, []));
       List.iter (fun f -> Queue.add f functions) fundecls;
       Cconst_symbol lbl
   | Uclosure(fundecls, clos_vars) ->
@@ -1655,7 +1663,6 @@ let rec transl env e =
           (untag_int (transl env arg))
           s.us_index_consts
           (Array.map (transl env) s.us_actions_consts)
-          dbg
       else if Array.length s.us_index_consts = 0 then
         transl_switch env (get_tag (transl env arg))
           s.us_index_blocks s.us_actions_blocks
@@ -2614,7 +2621,7 @@ let rec emit_structured_constant symb cst cont =
         (Misc.map_end (fun f -> Cdouble f) fields cont)
   | Uconst_closure(fundecls, lbl, fv) ->
       assert(lbl = fst symb);
-      constant_closures := (symb, fundecls, fv) :: !constant_closures;
+      add_cmm_constant (Const_closure (symb, fundecls, fv));
       List.iter (fun f -> Queue.add f functions) fundecls;
       cont
 
@@ -2701,6 +2708,12 @@ let emit_constant_closure ((_, global_symb) as symb) fundecls clos_vars cont =
         Csymbol_address f1.label ::
         emit_others 4 remainder
 
+(* Emit constant blocks *)
+
+let emit_constant_table symb elems =
+  cdefine_symbol symb @
+  elems
+
 (* Emit all structured constants *)
 
 let emit_constants cont (constants:Clambda.preallocated_constant list) =
@@ -2712,10 +2725,13 @@ let emit_constants cont (constants:Clambda.preallocated_constant list) =
          c:= Cdata(cst):: !c)
     constants;
   List.iter
-    (fun (symb, fundecls, clos_vars) ->
-        c := Cdata(emit_constant_closure symb fundecls clos_vars []) :: !c)
-    !constant_closures;
-  constant_closures := [];
+    (function
+    | Const_closure (symb, fundecls, clos_vars) ->
+        c := Cdata(emit_constant_closure symb fundecls clos_vars []) :: !c
+    | Const_table (symb, elems) ->
+        c := Cdata(emit_constant_table symb elems) :: !c)
+    !cmm_constants;
+  cmm_constants := [];
   !c
 
 let emit_all_constants cont =
diff --git a/testsuite/tests/basic/switch_opts.ml b/testsuite/tests/basic/switch_opts.ml
new file mode 100644
index 000000000..67034de3b
--- /dev/null
+++ b/testsuite/tests/basic/switch_opts.ml
@@ -0,0 +1,63 @@
+(* Test for optimisation of jump tables to arrays of constants *)
+
+let p = Printf.printf
+
+type test =
+  Test : 'b * 'a * ('b -> 'a) -> test
+
+type t = A | B | C
+
+(* These test functions need to have at least three cases.
+   Functions with fewer cases don't trigger the optimisation,
+   as they are compiled to if-then-else, not switch *)
+let testcases = [
+  Test (3, 3, function 1 -> 1 | 2 -> 2 | 3 -> 3 | _ -> 0);
+  Test (3, -3, function 1 -> 1 | 2 -> 2 | 3 -> -3 | _ -> 0);
+  Test (3, min_int, function 1 -> 1 | 2 -> 2 | 3 -> min_int | _ -> 0);
+  Test (3, max_int, function 1 -> 1 | 2 -> 2 | 3 -> max_int | _ -> 0);
+  Test (3, 3., function 1 -> 1. | 2 -> 2. | 3 -> 3. | _ -> 0.);
+  Test (3, Sys.opaque_identity "c" ^ Sys.opaque_identity "c",
+        function 1 -> "a" | 2 -> "b" | 3 -> "cc" | _ -> "");
+  Test (3, List.rev [3;2;1], function 1 -> [] | 2 -> [42] | 3 -> [1;2;3] | _ -> [415]);
+
+  Test (C, 3, function A -> 1 | B -> 2 | C -> 3);
+  Test (C, -3, function A -> 1 | B -> 2 | C -> -3);
+  Test (C, min_int, function A -> 1 | B -> 2 | C -> min_int);
+  Test (C, max_int, function A -> 1 | B -> 2 | C -> max_int);
+  Test (C, 3., function A -> 1. | B -> 2. | C -> 3.);
+  Test (C, "c", function A -> "a" | B -> "b" | C -> "c");
+  Test (C, List.rev [3;2;1], function A -> [] | B -> [42] | C -> [1;2;3]);
+
+  Test (42, 42, function
+  | 1 -> 1 | 2 -> 2 | 3 -> 3 | 4 -> 4 | 5 -> 5 | 6 -> 6 | 7 -> 7 | 8 -> 8
+  | 9 -> 9 | 10 -> 10 | 11 -> 11 | 12 -> 12 | 13 -> 13 | 14 -> 14 | 15 -> 15
+  | 16 -> 16 | 17 -> 17 | 18 -> 18 | 19 -> 19 | 20 -> 20 | 21 -> 21 | 22 -> 22
+  | 23 -> 23 | 24 -> 24 | 25 -> 25 | 26 -> 26 | 27 -> 27 | 28 -> 28 | 29 -> 29
+  | 30 -> 30 | 31 -> 31 | 32 -> 32 | 33 -> 33 | 34 -> 34 | 35 -> 35 | 36 -> 36
+  | 37 -> 37 | 38 -> 38 | 39 -> 39 | 40 -> 40 | 41 -> 41 | 42 -> 42 | 43 -> 43
+  | 44 -> 44 | 45 -> 45 | 46 -> 46 | 47 -> 47 | 48 -> 48 | 49 -> 49 | 50 -> 50
+  | 51 -> 51 | 52 -> 52 | 53 -> 53 | 54 -> 54 | 55 -> 55 | 56 -> 56 | 57 -> 57
+  | 58 -> 58 | 59 -> 59 | 60 -> 60 | 61 -> 61 | 62 -> 62 | 63 -> 63 | 64 -> 64
+  | 65 -> 65 | 66 -> 66 | 67 -> 67 | 68 -> 68 | 69 -> 69 | 70 -> 70 | 71 -> 71
+  | 72 -> 72 | 73 -> 73 | 74 -> 74 | 75 -> 75 | 76 -> 76 | 77 -> 77 | 78 -> 78
+  | 79 -> 79 | 80 -> 80 | 81 -> 81 | 82 -> 82 | 83 -> 83 | 84 -> 84 | 85 -> 85
+  | 86 -> 86 | 87 -> 87 | 88 -> 88 | 89 -> 89 | 90 -> 90 | 91 -> 91 | 92 -> 92
+  | 93 -> 93 | 94 -> 94 | 95 -> 95 | 96 -> 96 | 97 -> 97 | 98 -> 98 | 99 -> 99
+  | _ -> 0);
+
+  Test (3, `Tertiary, function
+  | 1 -> `Primary
+  | 2 -> `Secondary
+  | 3 -> `Tertiary
+  | n -> invalid_arg "test")
+  ]
+
+let passes = ref 0
+let run_test (Test (a, b, f)) =
+  assert (f a = b);
+  incr passes
+
+let () =
+  List.iter run_test testcases;
+  Printf.printf "%d tests passed\n" !passes
+
diff --git a/testsuite/tests/basic/switch_opts.reference b/testsuite/tests/basic/switch_opts.reference
new file mode 100644
index 000000000..48a004599
--- /dev/null
+++ b/testsuite/tests/basic/switch_opts.reference
@@ -0,0 +1 @@
+16 tests passed
-- 
2.11.0

